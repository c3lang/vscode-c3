%YAML 1.2
---
$schema: "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json"
name: C3
fileTypes:
  - c3
  - c3i
  - c3t
scopeName: source.c3

# How grammar scopes look on Github:
# https://github.com/Alhadis/language-etc/blob/master/samples/lists/scope-previews.nanorc

patterns:
  - include: "#top_level"
  - include: "#statements"

repository:
  top_level:
    patterns:
      - include: "#comments"

      # Modifier
      - include: "#modifier_keywords"

      # Compile Time Statements
      - begin: '\$(?:assert|include|echo|exec)\b'
        beginCaptures:
          0: { name: keyword.other.c3 }
        end: ;
        endCaptures:
          0: { name: punctuation.terminator.c3 }
        patterns:
          - include: "#comments"
          - include: "#expression"

      # Module
      - begin: \bmodule\b
        beginCaptures:
          0: { name: keyword.declaration.module.c3 }
        end: ;
        endCaptures:
          0: { name: punctuation.terminator.c3 }
        name: meta.module.c3
        patterns:
          - include: "#comments"
          - include: "#attribute"
          - include: "#module_path"
          - include: "#generic_args" # Deprecated
          - include: "#generic_params"

      # Import
      - begin: \bimport\b
        beginCaptures:
          0: { name: keyword.declaration.import.c3 }
        end: ;
        endCaptures:
          0: { name: punctuation.terminator.c3 }
        name: meta.import.c3
        patterns:
          - include: "#comments"
          - include: "#attribute"
          - include: "#module_path"
          - match: ','
            name: punctuation.separator.c3

      - include: "#function"

      # Alias
      - begin: '\balias\b'
        beginCaptures:
          0: { name: keyword.declaration.alias.c3 }
        end: ;
        endCaptures:
          0: { name: punctuation.terminator.c3 }
        name: meta.alias.c3
        patterns:
          - include: "#comments"
          # Module alias
          - begin: '(?=({{IDENT}})\s*=\s*module)'
            end: (?=;)
            patterns:
              - begin: '({{IDENT}})'
                end: (?=;)
                patterns:
                  - include: "#comments"
                  - include: "#attribute"
                  - begin: '='
                    beginCaptures:
                      0: { name: keyword.operator.assignment.c3 }
                    end: (?=;)
                    patterns:
                      - include: "#comments"
                      # Match module or expression
                      - begin: 'module'
                        beginCaptures:
                          0: { name: keyword.declaration.module.c3 }
                        end: (?=;)
                        patterns:
                          - include: "#comments"
                          - include: "#module_path"

          # Variable/function/macro/method/constant alias
          - begin: '(@{{IDENT}})|({{IDENT}})|({{CONST}})'
            beginCaptures:
              1: { name: entity.name.function.c3 }
              2: { name: variable.global.c3 } # Ambiguous: Could also be a function
              3: { name: variable.other.constant.c3 }
            end: (?=;)
            patterns:
              - include: "#comments"
              - include: "#generic_params"
              - include: "#attribute"
              - include: "#assign_right_expression"

          # Type/function signature alias
          - begin: '{{TYPE}}'
            beginCaptures:
              0: { name: <SCOPE_NAME_TYPE_DECL:> }
            end: (?=;)
            patterns:
              - include: "#comments"
              - include: "#generic_params"
              - include: "#attribute"
              - include: "#assign_right_expression"

      # Typedef
      - begin: '\btypedef\b'
        beginCaptures:
          0: { name: keyword.declaration.typedef.c3 }
        end: ';'
        endCaptures:
          0: { name: punctuation.terminator.c3 }
        name: meta.typedef.c3
        patterns:
          - include: "#comments"
          - begin: '{{TYPE}}'
            beginCaptures:
              0: { name: <SCOPE_NAME_TYPE_DECL:> }
            end: (?=;)
            patterns:
              - include: "#comments"
              # Interface implementation
              - include: "#parens"
              - include: "#generic_params"
              - include: "#attribute"
              - include: "#assign_right_expression"

      # Faultdef
      - begin: '\bfaultdef\b'
        beginCaptures:
          0: { name: keyword.declaration.faultdef.c3 }
        end: ';'
        endCaptures:
          0: { name: punctuation.terminator.c3 }
        name: meta.faultdef.c3
        patterns:
          - include: "#comments"
          - include: "#attribute"
          - match: '{{CONST}}'
            name: variable.other.constant.c3
          - match: ','
            name: punctuation.separator.c3
      
      # Attrdef
      - begin: '\battrdef\b'
        beginCaptures:
          0: { name: keyword.declaration.attrdef.c3 }
        end: ';'
        endCaptures:
          0: { name: punctuation.terminator.c3 }
        name: meta.attrdef.c3
        patterns:
          - include: "#comments"
          - begin: '@{{TYPE}}'
            beginCaptures:
              0: { name: keyword.annotation.c3 }
            end: (?=;)
            patterns:
              - include: "#comments"
              - include: "#attribute"
              # Parameters
              - begin: \(
                beginCaptures:
                  0: { name: punctuation.section.group.begin.c3 }
                end: \)
                endCaptures:
                  0: { name: punctuation.section.group.end.c3 }
                name: meta.group.c3
                patterns:
                  - include: "#parameters"
              - begin: '='
                beginCaptures:
                  0: { name: keyword.operator.assignment.c3 }
                end: (?=;)
                patterns:
                  - include: "#comments"
                  - include: "#attribute"
                  - match: ','
                    name: punctuation.separator.c3

      # Struct/Bitstruct/Union (structlikes)
      - include: "#structlike"

      # Enum
      - begin: '(?=\benum\b)'
        end: (?<=\})
        patterns:
          - begin: '\benum\b'
            beginCaptures:
              0: { name: keyword.declaration.enum.c3 }
            end: (?=\{)
            name: meta.enum.c3
            patterns:
              - include: "#comments"
              - match: '{{TYPE}}'
                name: <SCOPE_NAME_TYPE_DECL:enum>
              - include: "#generic_params"
              - include: "#attribute"
              - begin: ':'
                beginCaptures:
                  0 : { name: punctuation.separator.c3 }
                end: (?=\{)
                patterns:
                  - include: "#comments"
                  - match: '\b(?:inline|const)\b'
                    name: storage.modifier.c3
                  - include: "#type_no_generics"
                  # Enum parameters
                  - begin: '\('
                    beginCaptures:
                      0: { name: punctuation.section.group.begin.c3 }
                    end: '\)'
                    endCaptures:
                      0: { name: punctuation.section.group.end.c3 }
                    contentName: meta.group.c3
                    patterns:
                      - include: "#comments"
                      - match: '\b(?:inline|const)\b'
                        name: storage.modifier.c3
                      - include: "#parameters"
                  - include: "#generic_params"
                  - include: "#attribute"
          # Enum body
          - begin: \{
            beginCaptures:
              0: { name: punctuation.section.block.begin.c3 }
            end: \}
            endCaptures:
              0: { name: punctuation.section.block.end.c3 }
            name: meta.enum.body.c3
            patterns:
              - include: "#comments"
              - begin: '='
                beginCaptures:
                  0: { name: keyword.operator.assignment.c3 }
                end: (?=,)
                patterns:
                  - include: "#expression"
              - include: "#attribute"
              - match: '{{CONST}}'
                name: variable.other.constant.c3
              - match: ','
                name: punctuation.separator.c3

      # Interface
      - begin: '(?=\binterface\b)'
        end: (?<=\})
        patterns:
          - begin: '\binterface\b'
            beginCaptures:
              0: { name: keyword.declaration.interface.c3 }
            end: (?=\{)
            name: meta.interface.c3
            patterns:
              - include: "#comments"
              - match: '{{TYPE}}'
                name: <SCOPE_NAME_TYPE_DECL:interface>
              - include: "#generic_params"
              - include: "#attribute"
              - begin: ':'
                beginCaptures:
                  0 : { name: punctuation.separator.c3 }
                end: (?=\{)
                patterns:
                  - include: "#comments"
                  - include: "#punctuation"
                  - include: "#type_no_generics"
          # Interface body
          - begin: \{
            beginCaptures:
              0: { name: punctuation.section.block.begin.c3 }
            end: \}
            endCaptures:
              0: { name: punctuation.section.block.end.c3 }
            name: meta.interface.body.c3
            patterns:
              - include: "#comments"
              - match: ';'
                name: punctuation.terminator.c3
              - include: "#function"

  assign_right_expression:
    begin: '='
    beginCaptures:
      0: { name: keyword.operator.assignment.c3 }
    end: (?=;)
    patterns:
      - include: "#comments"
      - include: "#expression"
  
  function_header:
    patterns:
      - include: "#type"
      - match: '\.'
        name: punctuation.accessor.c3
      - match: '@?{{IDENT}}'
        name: entity.name.function.c3

  function:
    begin: (?=\b(fn|macro)\b)
    end: (?=[={;])
    patterns:
      # Before parameters
      - begin: \b(fn|macro)\b
        beginCaptures:
          1: { name: keyword.declaration.function.c3 }
        end: '(?=\()'
        name: meta.function.c3
        patterns:
          - include: "#comments"
          - include: "#function_header"
      # Parameters
      - begin: \(
        beginCaptures:
          0: { name: punctuation.section.group.begin.c3 }
        end: \)
        endCaptures:
          0: { name: punctuation.section.group.end.c3 }
        name: meta.function.parameters.c3
        patterns:
          - include: "#parameters"
      # After parameters
      - begin: '(?<=\))'
        end: (?=[{=;])
        contentName: meta.function.c3
        patterns:
          - include: "#comments"
          - include: "#generic_params"
          - include: "#attribute"

  structlike:
    begin: '(?=\b(?:(struct|bitstruct)|(union))\b)'
    end: (?<=\})
    patterns:
      - begin: '\b(?:(struct|bitstruct)|(union))\b'
        beginCaptures:
          1: { name: keyword.declaration.struct.c3 }
          2: { name: keyword.declaration.union.c3 }
        end: (?=\{)
        name: meta.struct.c3
        patterns:
          - include: "#comments"
          - match: '{{TYPE}}'
            name: <SCOPE_NAME_TYPE_DECL:struct>
          - match: '{{IDENT}}'
            name: variable.other.member.c3
          - include: "#generic_params"
          - include: "#attribute"
          - begin: ':'
            beginCaptures:
              0 : { name: punctuation.separator.c3 }
            end: (?=\{)
            patterns:
              - include: "#comments"
              - include: "#type_no_generics"
              - include: "#generic_params"
              - include: "#attribute"
          # Interface implementation
          - begin: '\('
            beginCaptures:
              0: { name: punctuation.section.group.begin.c3 }
            end: '\)'
            endCaptures:
              0: { name: punctuation.section.group.end.c3 }
            name: meta.group.c3
            patterns:
              - include: "#comments"
              - include: "#path"
              - include: "#type"
              - include: "#punctuation"
      # Struct body
      - begin: \{
        beginCaptures:
          0: { name: punctuation.section.block.begin.c3 }
        end: \}
        endCaptures:
          0: { name: punctuation.section.block.end.c3 }
        name: meta.struct.body.c3
        patterns:
          - include: "#comments"
          - include: "#structlike"
          - include: "#modifier_keywords"
          - include: "#type"
          - match: '{{IDENT}}'
            name: variable.other.member.c3
          - include: "#attribute"
          - match: ';'
            name: punctuation.terminator.c3
          # Bitstruct
          - begin: ':'
            beginCaptures:
              0 : { name: punctuation.separator.c3 }
            end: (?=;)
            patterns:
              - include: "#attribute"
              - include: "#expression"

  builtin:
    patterns:
      - match: '(\$\${{CONST}})|(\$\${{IDENT}})'
        captures:
          1: { name: constant.language.c3 }
          2: { name: entity.name.function.builtin.c3 }

  keywords:
    patterns:
      - match: '\$(?:{{ct_keyword}})\b'
        name: keyword.other.ct.c3
      - match: '\$(?:{{ct_control_keyword}})\b'
        name: keyword.control.ct.c3
      - match: '\b(?:{{keyword}})\b'
        name: keyword.other.c3
      - match: '\b(?:{{control_keyword}})\b'
        name: keyword.control.c3

  modifier_keywords:
    patterns:
      - match: '\b(?:const|extern|static|tlocal|inline)\b'
        name: storage.modifier.c3

  punctuation:
    patterns:
      # No semicolon here because we always match it separately
      - match: ','
        name: punctuation.separator.c3
      - match: ':'
        name: punctuation.separator.c3
      - match: '\.(?!\.\.)'
        name: punctuation.accessor.c3

  constants:
    patterns:
      - match: '\b(true|false|null)\b'
        name: constant.language.c3
      - begin: '{{CONST}}'
        beginCaptures: {
          0: { name: variable.other.constant.c3 }
        }
        end: '(?=[^{ \t])|(?<=\})' # ' \t' instead of '\s' because doc comments are newline sensitive
        patterns:
          - include: "#generic_args"

  operators:
    patterns:
      - match: '=>'
        name: keyword.declaration.function.arrow.c3
      - match: '(?:[-%&*+/^|]|>>|<<|\+\+\+)='
        name: keyword.operator.assignment.augmented.c3
      - match: '<=|>=|==|<|>|!='
        name: keyword.operator.comparison.c3
      - match: '\.\.\.'
        name: keyword.operator.variadic.c3
      - match: '\.\.'
        name: keyword.operator.range.c3
      - match: '\+\+\+?|--'
        name: keyword.operator.arithmetic.c3
      - match: '<<|>>|&&&?|\|\|\|?'
        name: keyword.operator.arithmetic.c3
      - match: '[-%+/^|~]'
        name: keyword.operator.arithmetic.c3
      - match: '='
        name: keyword.operator.assignment.c3
      - match: '\?\?\??|\?:|[!?]|[&*:]'
        name: keyword.operator.c3

  path:
    match: '({{IDENT}})\s*(::)'
    captures:
      1: { name: entity.name.scope-resolution.c3 }
      2: { name: punctuation.separator.scope-resolution.c3 }
    name: meta.path.c3

  module_path:
    patterns:
      - include: "#path"
      - match: '({{IDENT}})'
        captures:
          1: { name: entity.name.scope-resolution.c3 }
        name: meta.path.c3

  literals:
    patterns:
      - include: "#string_literal"
      - include: "#char_literal"
      - include: "#raw_string_literal"
      - include: "#real_literal"
      - include: "#integer_literal"
      - include: "#bytes_literal"

  escape_sequence:
    match: '\\([0abefnrtv''"\\]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|U[0-9a-fA-F]{8})'
    name: constant.character.escape.c3

  char_literal:
    begin: "'"
    beginCaptures:
      0: { name: punctuation.definition.string.begin.c3 }
    end: "'"
    endCaptures:
      0: { name: punctuation.definition.string.end.c3 }
    name: string.quoted.single.c3
    patterns:
      - include: "#escape_sequence"

  string_literal:
    begin: '"'
    beginCaptures:
      0: { name: punctuation.definition.string.begin.c3 }
    end: '"'
    endCaptures:
      0: { name: punctuation.definition.string.end.c3 }
    name: string.quoted.double.c3
    patterns:
      - include: "#escape_sequence"

  raw_string_literal:
    begin: '`'
    beginCaptures:
      0: { name: punctuation.definition.string.begin.c3 }
    end: '`(?!`)'
    endCaptures:
      0: { name: punctuation.definition.string.end.c3 }
    name: string.quoted.other.c3
    patterns:
      - match: '``'
        name: constant.character.escape.c3

  real_literal:
    patterns:
      - match: '\b{{INT}}{{REALTYPE}}'
        name: constant.numeric.float.c3
      - match: '\b(?:{{INT}}{{E}}|{{INT}}\.(?!\.)(?:{{INT}})?(?:{{E}})?){{REALTYPE}}?'
        name: constant.numeric.float.c3
      - match: '\b0[xX]{{HINT}}(?:\.(?:{{HINT}})?)?{{P}}{{REALTYPE}}?'
        name: constant.numeric.float.c3

  integer_literal:
    match: '\b(?:0[xX]{{HINT}}|0[oO]{{OINT}}|0[bB]{{BINT}}|{{INT}}){{INTTYPE}}?'
    name: constant.numeric.integer.c3

  bytes_literal:
    patterns:
      - begin: "(x)([\"'`])"
        beginCaptures:
          1: { name: keyword.other.c3 }
          2: { name: punctuation.definition.string.begin.c3 }
        end: "\\2"
        endCaptures:
          0: { name: punctuation.definition.string.end.c3 }
        name: string.quoted.other.c3
        patterns:
          - match: '[\sfA-Fa-f0-9]+'
            name: constant.numeric.integer.c3
      - begin: "(b64)([\"'`])"
        beginCaptures:
          1: { name: keyword.other.c3 }
          2: { name: punctuation.definition.string.begin.c3 }
        end: "\\2"
        endCaptures:
          0: { name: punctuation.definition.string.end.c3 }
        name: string.quoted.other.c3
        patterns:
          - match: '[\sA-Za-z0-9+/=]+'
            name: constant.numeric.integer.c3

  comments:
    patterns:
      - include: "#line_comment"
      - include: "#block_comment"
      - include: "#doc_comment"

  line_comment:
    match: //.*$
    name: comment.line.double-slash.c3

  block_comment:
    begin: '/\*'
    beginCaptures:
      0: { name: punctuation.definition.comment.begin.c3 }
    end: '\*/'
    endCaptures:
      0: { name: punctuation.definition.comment.end.c3 }
    name: comment.block.c3
    patterns:
      - include: "#block_comment_body"

  block_comment_body:
    patterns:
      - begin: '/\*'
        end: '\*/'
        patterns:
          - include: "#block_comment_body"

  doc_comment:
    begin: '(?=<\*)'
    end: '(\*>)'
    endCaptures:
      0: { name: comment.block.documentation.c3 }
      1: { name: punctuation.definition.comment.end.c3 }
    patterns:
      - include: "#doc_comment_body"

  doc_comment_body:
    patterns:
      # Match doc comment start with first contract on same line
      - begin: '(<\*)\s*(?=@)'
        beginCaptures:
          0: { name: comment.block.documentation.c3 }
          1: { name: punctuation.definition.comment.begin.c3 }
        end: '(?=\*>)'
        patterns:
          # Highlight parameter names
          - match: '@param(?:\s*\[&?(?:in|out|inout)\])?\s*(?:([$#]?{{IDENT}})|(\${{TYPE}})|(\.\.\.))'
            captures:
              0: { name: comment.block.documentation.c3 }
              1: { name: variable.parameter.c3 }
              2: { name: <SCOPE_NAME_TYPE_USE> }
              3: { name: keyword.operator.variadic.c3 }
          - begin: '@(?:require\b|ensure\b|return\?)'
            beginCaptures:
              0: { name: comment.block.documentation.c3 }
            end: '(?=:|\*>|$)'
            patterns:
              - include: "#expression"
          - match: '@{{IDENT}}'
            name: comment.block.documentation.c3
          - match: ':'
            name: comment.block.documentation.c3
          - begin: '(["`])'
            end: '\1'
            name: comment.block.documentation.c3
      - begin: '(<\*)'
        beginCaptures:
          0: { name: comment.block.documentation.c3 }
          1: { name: punctuation.definition.comment.begin.c3 }
        end: '(?=^\s*@|\*>)'
        name: comment.block.documentation.c3
      # Match contracts
      - begin: ''
        end: '(?=\*>)'
        patterns:
          # Highlight parameter names
          - match: '^\s*@param(?:\s*\[&?(?:in|out|inout)\])?\s*(?:([$#]?{{IDENT}})|(\${{TYPE}})|(\.\.\.))'
            captures:
              0: { name: comment.block.documentation.c3 }
              1: { name: variable.parameter.c3 }
              2: { name: <SCOPE_NAME_TYPE_USE> }
              3: { name: keyword.operator.variadic.c3 }
          - begin: '^\s*@(?:require\b|ensure\b|return\?)'
            beginCaptures:
              0: { name: comment.block.documentation.c3 }
            end: '(?=:|\*>|$)'
            patterns:
              - include: "#expression"
          - match: '^\s*@{{IDENT}}'
            name: comment.block.documentation.c3
          - match: ':'
            name: comment.block.documentation.c3
          - begin: '(["`])'
            end: '\1'
            name: comment.block.documentation.c3

  type_suffix:
    patterns:
      - include: "#brackets"
      - match: '\*'
        name: keyword.operator.address.c3
      - match: '\?'
        name: keyword.operator.c3

  type:
    patterns:
      - include: "#path"
      - begin: '\b({{base_type}})\b|(\$?\b{{TYPE}}\b)'
        beginCaptures:
          1: { name: storage.type.built-in.primitive.c3 }
          2: { name: <SCOPE_NAME_TYPE_USE> }
        end: (?=\*>|[^ \t*\[?{]) # ' \t' instead of '\s' because doc comments are newline sensitive
        patterns:
          - include: "#comments"
          - include: "#generic_args"
          - include: "#type_suffix"
      - include: "#type_expr"

  type_no_generics:
    patterns:
      - include: "#path"
      - begin: '\b({{base_type}})\b|(\$?\b{{TYPE}}\b)'
        beginCaptures:
          1: { name: storage.type.built-in.primitive.c3 }
          2: { name: <SCOPE_NAME_TYPE_USE> }
        end: (?=[^ \t*\[?@]) # ' \t' instead of '\s' because doc comments are newline sensitive
        patterns:
          - include: "#comments"
          - include: "#type_suffix"
      - include: "#type_expr"
  
  type_expr:
    patterns:
      - begin: '\$(?:typeof|typefrom|evaltype)\b'
        beginCaptures:
          0: { name: storage.type.c3 }
        end: (?<=\))
        patterns:
          - include: "#parens"
      - begin: '\$vatype\b' 
        beginCaptures:
          0: { name: storage.type.c3 }
        end: (?<=\])
        patterns:
          - include: "#brackets"
      # Matching type suffix after typeof/typefrom etc. is too hard so just do generic matches here
      - include: "#type_suffix"

  attribute:
    patterns:
      - begin: '@(?:(?:{{attribute}})\b|{{TYPE}})'
        beginCaptures:
          0: { name: keyword.annotation.c3 }
        end: '(?=[^ \t(])|(?<=\))' # ' \t' instead of '\s' because doc comments are newline sensitive
        name: meta.annotation.c3
        patterns:
          - include: "#parens"

  control_statements:
    patterns:
      # CT for
      - begin: \$for\b
        beginCaptures:
          0: { name: keyword.control.ct.c3 }
        end: ':'
        endCaptures:
          0: { name: punctuation.separator.c3 } # Override the : operator
        patterns:
          - include: "#statements"
      # CT foreach
      - begin: \$foreach\b
        beginCaptures:
          0: { name: keyword.control.ct.c3 }
        end: '(?<=:)'
        patterns:
          - include: "#comments"
          - match: '\${{IDENT}}'
            name: variable.other.c3
          - match: ','
            name: punctuation.separator.c3
          - begin: ':'
            beginCaptures:
              0: { name: keyword.operator.c3 }
            end: ':'
            endCaptures:
              0: { name: punctuation.separator.c3 } # Override the : operator
            patterns:
              - include: "#expression"
      # for
      - begin: \bfor\b
        beginCaptures:
          0: { name: keyword.control.c3 }
        end: (?<=\))
        patterns:
          - include: "#comments"
          - begin: \(
            beginCaptures:
              0: { name: punctuation.section.group.begin.c3 }
            end: \)
            endCaptures:
              0: { name: punctuation.section.group.end.c3 }
            patterns:
              - include: "#statements"
      # CT switch/case/default/if
      - begin: '\$(?:switch|case|default|if)\b'
        beginCaptures:
          0: { name: keyword.control.ct.c3 }
        end: ':'
        endCaptures:
          0: { name: punctuation.separator.c3 } # Override the : operator
        patterns:
          - include: "#expression"
      # case/default
      - begin: '\b(?:case|default)\b'
        beginCaptures:
          0: { name: keyword.control.c3 }
        end: ':'
        endCaptures:
          0: { name: punctuation.separator.c3 } # Override the : operator
        patterns:
          - include: "#expression"

  statements:
    patterns:
      - include: "#comments"
      - include: "#modifier_keywords"
      - match: ';'
        name: punctuation.terminator.c3

      - include: "#control_statements"
      # Include attributes for declarations (we don't parse declarations)
      # Have known attribute names take priority, even though it could be a valid macro call
      - include: "#attribute" 

      - include: "#block"
      - include: "#expression"

  variable:
    begin: '(?<!#)\$?{{IDENT}}'
    beginCaptures:
      0: { name: variable.other.c3 }
    end: '(?=[^{ \t])|(?<=\})' # ' \t' instead of '\s' because doc comments are newline sensitive
    patterns:
      - include: "#generic_args"

  leftover_at_ident:
    patterns:
      # Inline call attributes
      - match: '@(?:pure|inline|noinline)'
        captures:
          0: { name: keyword.annotation.c3 }
        name: meta.annotation.c3
      # Macro name
      - begin: '@{{IDENT}}'
        beginCaptures:
          0: { name: entity.name.function.c3 }
        end: '(?=[^{ \t])|(?<=\})' # ' \t' instead of '\s' because doc comments are newline sensitive
        patterns:
          - include: "#generic_args"

  expression:
    patterns:
      - include: "#comments"
      - include: "#function"
      - include: "#constants"
      - include: "#builtin"
      - include: "#literals"
      - include: "#operators"
      - include: "#keywords"
      - include: "#type"
      - include: "#path"
      - include: "#function_call"
      - include: "#variable"
      - include: "#parens"
      - include: "#brackets"
      # Just assume anything in curly braces is a block of statements (even if it's an initializer list)
      - include: "#block"
      - include: "#punctuation"
      # Pick up unmatched @ident, assume it's a function call attribute or a macro identifier
      - include: "#leftover_at_ident"

  function_call:
    begin: '([@#]?{{IDENT}})(?=\s*(\{.*\})?\s*\()' # TODO using \s* doesn't match over multiple lines
    beginCaptures:
      1: { name: entity.name.function.c3 }
    end: '(?<=\))'
    name: meta.function_call.c3
    patterns:
      - include: "#generic_args"
      # Argument list
      - begin: \(
        beginCaptures:
          0: { name: punctuation.section.group.begin.c3 }
        end: \)
        endCaptures:
          0: { name: punctuation.section.group.end.c3 }
        name: meta.group.c3
        patterns:
          - include: "#comments"
          # Named argument
          - begin: '([$#]?{{IDENT}}|\${{TYPE}})\s*(:)(?!:)'
            beginCaptures:
              1: { name: variable.parameter.c3 }
              2: { name: punctuation.separator.c3 }
            end: '(?=\))|([;,])'
            endCaptures:
              1: { name: punctuation.separator.c3 }
            patterns:
              - include: "#expression"
          # Unnamed argument
          - begin: (?=\S)
            end: '(?=\))|([;,])'
            endCaptures:
              1: { name: punctuation.separator.c3 }
            patterns:
              - include: "#expression"
          - match: ';'
            name: punctuation.separator.c3

  block:
    patterns:
      - begin: \{
        beginCaptures:
          0: { name: punctuation.section.block.begin.c3 }
        end: \}
        endCaptures:
          0: { name: punctuation.section.block.end.c3 }
        name: meta.block.c3
        patterns:
          - include: "#statements"

  parens:
    patterns:
      - begin: \(
        beginCaptures:
          0: { name: punctuation.section.group.begin.c3 }
        end: \)
        endCaptures:
          0: { name: punctuation.section.group.end.c3 }
        name: meta.group.c3
        patterns:
          - include: "#expression"

  brackets:
    patterns:
      - begin: '\[<?'
        beginCaptures:
          0: { name: punctuation.section.brackets.begin.c3 }
        end: '>?\]'
        endCaptures:
          0: { name: punctuation.section.brackets.end.c3 }
        name: meta.brackets.c3
        patterns:
          - include: "#expression"

  parameters:
    patterns:
      - include: "#comments"
      # CT type parameter, before #type
      - begin: '\${{TYPE}}'
        beginCaptures:
          0 : { name: <SCOPE_NAME_TYPE_USE> }
        end: '(?=[;,)])'
        patterns:
          - include: "#comments"
          - include: "#attribute"
          # CT type parameter with default value
          - begin: '='
            beginCaptures:
              0 : { name: keyword.operator.assignment.c3 }
            end: '(?=[;,)])'
            patterns:
              - include: "#expression"

      - include: "#type"
      - include: "#punctuation"
      - match: '\.\.\.'
        name: keyword.operator.variadic.c3
      - match: '&'
        name: keyword.operator.address.c3
      # Macro body parameter
      - begin: ';'
        beginCaptures:
          0: { name: punctuation.separator.c3 }
        end: '(?=\))'
        patterns:
          - include: "#comments"
          - match: '@{{IDENT}}'
            name: entity.name.function.c3
          - include: "#parameters"
      # Parameter
      - begin: '[$#]?{{IDENT}}'
        beginCaptures:
          0 : { name: variable.parameter.c3 }
        end: '(?=[;,)])'
        patterns:
          - include: "#comments"
          - include: "#attribute"
          - match: '\.\.\.'
            name: keyword.operator.variadic.c3
          # Parameter with default value
          - begin: '='
            beginCaptures:
              0 : { name: keyword.operator.assignment.c3 }
            end: '(?=[;,)])'
            patterns:
              - include: "#expression"

  generic_args:
    patterns:
      - begin: \{
        end: \}
        beginCaptures:
          0: { name: punctuation.definition.generic.begin.c3 }
        endCaptures:
          0: { name: punctuation.definition.generic.end.c3 }
        name: meta.generic.c3
        patterns:
          - include: "#expression"

  generic_params:
    patterns:
      - begin: '<'
        end: '>'
        beginCaptures:
          0: { name: punctuation.definition.generic.begin.c3 }
        endCaptures:
          0: { name: punctuation.definition.generic.end.c3 }
        name: meta.generic.c3
        patterns:
          - include: "#comments"
          - match: '{{TYPE}}'
            name: <SCOPE_NAME_TYPE_USE>
          - match: '{{CONST}}'
            name: variable.other.constant.c3
          - match: ','
            name: punctuation.separator.c3